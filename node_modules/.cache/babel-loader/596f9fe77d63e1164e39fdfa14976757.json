{"ast":null,"code":"import layerEvents from \"../../lib/layerEvents\";\nimport mixin from \"./layerMixin\";\nexport default {\n  name: \"GeojsonLayer\",\n  mixins: [mixin],\n  computed: {\n    getSourceFeatures() {\n      return filter => {\n        if (this.map) {\n          return this.map.querySourceFeatures(this.sourceId, {\n            filter\n          });\n        }\n\n        return null;\n      };\n    },\n\n    getRenderedFeatures() {\n      return (geometry, filter) => {\n        if (this.map) {\n          return this.map.queryRenderedFeatures(geometry, {\n            layers: [this.layerId],\n            filter\n          });\n        }\n\n        return null;\n      };\n    },\n\n    getClusterExpansionZoom() {\n      return clusterId => {\n        return new Promise((resolve, reject) => {\n          if (this.mapSource) {\n            this.mapSource.getClusterExpansionZoom(clusterId, (err, zoom) => {\n              if (err) {\n                return reject(err);\n              }\n\n              return resolve(zoom);\n            });\n          } else {\n            return reject(new Error(`Map source with id ${this.sourceId} not found.`));\n          }\n        });\n      };\n    },\n\n    getClusterChildren() {\n      return clusterId => {\n        return new Promise((resolve, reject) => {\n          const source = this.mapSource;\n\n          if (source) {\n            source.getClusterChildren(clusterId, (err, features) => {\n              if (err) {\n                return reject(err);\n              }\n\n              return resolve(features);\n            });\n          } else {\n            return reject(new Error(`Map source with id ${this.sourceId} not found.`));\n          }\n        });\n      };\n    },\n\n    getClusterLeaves() {\n      return (...args) => {\n        return new Promise((resolve, reject) => {\n          if (this.mapSource) {\n            this.mapSource.getClusterLeaves(...args, (err, features) => {\n              if (err) {\n                return reject(err);\n              }\n\n              return resolve(features);\n            });\n          } else {\n            return reject(new Error(`Map source with id ${this.sourceId} not found.`));\n          }\n        });\n      };\n    }\n\n  },\n\n  created() {\n    if (this.source) {\n      this.$watch(\"source.data\", function (next) {\n        if (this.initial) return;\n        this.mapSource.setData(next);\n      }, {\n        deep: true\n      });\n    }\n\n    this.$_deferredMount();\n  },\n\n  methods: {\n    $_deferredMount() {\n      // this.map = payload.map;\n      this.map.on(\"dataloading\", this.$_watchSourceLoading);\n\n      if (this.source) {\n        const source = {\n          type: \"geojson\",\n          ...this.source\n        };\n\n        try {\n          this.map.addSource(this.sourceId, source);\n        } catch (err) {\n          if (this.replaceSource) {\n            this.map.removeSource(this.sourceId);\n            this.map.addSource(this.sourceId, source);\n          }\n        }\n      }\n\n      this.$_addLayer();\n      this.$_bindLayerEvents(layerEvents);\n      this.map.off(\"dataloading\", this.$_watchSourceLoading);\n      this.initial = false;\n    },\n\n    $_addLayer() {\n      let existed = this.map.getLayer(this.layerId);\n\n      if (existed) {\n        if (this.replace) {\n          this.map.removeLayer(this.layerId);\n        } else {\n          this.$_emitEvent(\"layer-exists\", {\n            layerId: this.layerId\n          });\n          return existed;\n        }\n      }\n\n      const layer = {\n        id: this.layerId,\n        source: this.sourceId,\n        ...this.layer\n      };\n      this.map.addLayer(layer, this.before);\n      this.$_emitEvent(\"added\", {\n        layerId: this.layerId\n      });\n    },\n\n    setFeatureState(featureId, state) {\n      if (this.map) {\n        const params = {\n          id: featureId,\n          source: this.source\n        };\n        return this.map.setFeatureState(params, state);\n      }\n    },\n\n    getFeatureState(featureId) {\n      if (this.map) {\n        const params = {\n          id: featureId,\n          source: this.source\n        };\n        return this.map.getFeatureState(params);\n      }\n    },\n\n    removeFeatureState(featureId, sourceLayer, key) {\n      if (this.map) {\n        const params = {\n          id: featureId,\n          source: this.source,\n          sourceLayer\n        };\n        return this.map.removeFeatureState(params, key);\n      }\n    }\n\n  }\n};","map":{"version":3,"sources":["/Users/muhammad/Ayaz/express-vue3-tailwind-map/client/node_modules/vue-mapbox/src/components/layer/GeojsonLayer.js"],"names":["layerEvents","mixin","name","mixins","computed","getSourceFeatures","filter","map","querySourceFeatures","sourceId","getRenderedFeatures","geometry","queryRenderedFeatures","layers","layerId","getClusterExpansionZoom","clusterId","Promise","resolve","reject","mapSource","err","zoom","Error","getClusterChildren","source","features","getClusterLeaves","args","created","$watch","next","initial","setData","deep","$_deferredMount","methods","on","$_watchSourceLoading","type","addSource","replaceSource","removeSource","$_addLayer","$_bindLayerEvents","off","existed","getLayer","replace","removeLayer","$_emitEvent","layer","id","addLayer","before","setFeatureState","featureId","state","params","getFeatureState","removeFeatureState","sourceLayer","key"],"mappings":"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","sourcesContent":["import layerEvents from \"../../lib/layerEvents\";\nimport mixin from \"./layerMixin\";\n\nexport default {\n  name: \"GeojsonLayer\",\n  mixins: [mixin],\n\n  computed: {\n    getSourceFeatures() {\n      return filter => {\n        if (this.map) {\n          return this.map.querySourceFeatures(this.sourceId, { filter });\n        }\n        return null;\n      };\n    },\n\n    getRenderedFeatures() {\n      return (geometry, filter) => {\n        if (this.map) {\n          return this.map.queryRenderedFeatures(geometry, {\n            layers: [this.layerId],\n            filter\n          });\n        }\n        return null;\n      };\n    },\n\n    getClusterExpansionZoom() {\n      return clusterId => {\n        return new Promise((resolve, reject) => {\n          if (this.mapSource) {\n            this.mapSource.getClusterExpansionZoom(clusterId, (err, zoom) => {\n              if (err) {\n                return reject(err);\n              }\n              return resolve(zoom);\n            });\n          } else {\n            return reject(\n              new Error(`Map source with id ${this.sourceId} not found.`)\n            );\n          }\n        });\n      };\n    },\n\n    getClusterChildren() {\n      return clusterId => {\n        return new Promise((resolve, reject) => {\n          const source = this.mapSource;\n          if (source) {\n            source.getClusterChildren(clusterId, (err, features) => {\n              if (err) {\n                return reject(err);\n              }\n              return resolve(features);\n            });\n          } else {\n            return reject(\n              new Error(`Map source with id ${this.sourceId} not found.`)\n            );\n          }\n        });\n      };\n    },\n\n    getClusterLeaves() {\n      return (...args) => {\n        return new Promise((resolve, reject) => {\n          if (this.mapSource) {\n            this.mapSource.getClusterLeaves(...args, (err, features) => {\n              if (err) {\n                return reject(err);\n              }\n              return resolve(features);\n            });\n          } else {\n            return reject(\n              new Error(`Map source with id ${this.sourceId} not found.`)\n            );\n          }\n        });\n      };\n    }\n  },\n\n  created() {\n    if (this.source) {\n      this.$watch(\n        \"source.data\",\n        function(next) {\n          if (this.initial) return;\n          this.mapSource.setData(next);\n        },\n        { deep: true }\n      );\n    }\n    this.$_deferredMount();\n  },\n\n  methods: {\n    $_deferredMount() {\n      // this.map = payload.map;\n      this.map.on(\"dataloading\", this.$_watchSourceLoading);\n      if (this.source) {\n        const source = {\n          type: \"geojson\",\n          ...this.source\n        };\n        try {\n          this.map.addSource(this.sourceId, source);\n        } catch (err) {\n          if (this.replaceSource) {\n            this.map.removeSource(this.sourceId);\n            this.map.addSource(this.sourceId, source);\n          }\n        }\n      }\n      this.$_addLayer();\n      this.$_bindLayerEvents(layerEvents);\n      this.map.off(\"dataloading\", this.$_watchSourceLoading);\n      this.initial = false;\n    },\n\n    $_addLayer() {\n      let existed = this.map.getLayer(this.layerId);\n      if (existed) {\n        if (this.replace) {\n          this.map.removeLayer(this.layerId);\n        } else {\n          this.$_emitEvent(\"layer-exists\", { layerId: this.layerId });\n          return existed;\n        }\n      }\n      const layer = {\n        id: this.layerId,\n        source: this.sourceId,\n        ...this.layer\n      };\n      this.map.addLayer(layer, this.before);\n      this.$_emitEvent(\"added\", { layerId: this.layerId });\n    },\n\n    setFeatureState(featureId, state) {\n      if (this.map) {\n        const params = { id: featureId, source: this.source };\n        return this.map.setFeatureState(params, state);\n      }\n    },\n\n    getFeatureState(featureId) {\n      if (this.map) {\n        const params = { id: featureId, source: this.source };\n        return this.map.getFeatureState(params);\n      }\n    },\n\n    removeFeatureState(featureId, sourceLayer, key) {\n      if (this.map) {\n        const params = {\n          id: featureId,\n          source: this.source,\n          sourceLayer\n        };\n        return this.map.removeFeatureState(params, key);\n      }\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"module"}