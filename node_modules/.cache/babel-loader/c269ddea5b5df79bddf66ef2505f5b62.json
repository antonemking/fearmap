{"ast":null,"code":"const watchers = {\n  maxBounds(next) {\n    this.map.setMaxBounds(next);\n  },\n\n  minZoom(next) {\n    this.map.setMinZoom(next);\n  },\n\n  maxZoom(next) {\n    this.map.setMaxZoom(next);\n  },\n\n  mapStyle(next) {\n    this.map.setStyle(next);\n  },\n\n  // TODO: make 'bounds' synced prop\n  // bounds (next) { this.map.fitBounds(next, { linear: true, duration: 0 }) },\n  collisionBoxes(next) {\n    this.map.showCollisionBoxes = next;\n  },\n\n  tileBoundaries(next) {\n    this.map.showTileBoundaries = next;\n  },\n\n  repaint(next) {\n    this.map.repaint = next;\n  },\n\n  zoom(next) {\n    this.map.setZoom(next);\n  },\n\n  center(next) {\n    this.map.setCenter(next);\n  },\n\n  bearing(next) {\n    this.map.setBearing(next);\n  },\n\n  pitch(next) {\n    this.map.setPitch(next);\n  },\n\n  light(next) {\n    this.map.setLigh(next);\n  }\n\n};\n\nfunction watcher(prop, callback, next, prev) {\n  if (this.initial) return;\n\n  if (this.$listeners[`update:${prop}`]) {\n    if (this.propsIsUpdating[prop]) {\n      this._watcher.active = false;\n      this.$nextTick(() => {\n        this._watcher.active = true;\n      });\n    } else {\n      this._watcher.active = true;\n      callback(next, prev);\n    }\n\n    this.propsIsUpdating[prop] = false;\n  } else {\n    callback(next, prev);\n  }\n}\n\nfunction makeWatchers() {\n  const wrappers = {};\n  Object.entries(watchers).forEach(prop => {\n    wrappers[prop[0]] = function (next, prev) {\n      return watcher.call(this, prop[0], prop[1].bind(this), next, prev);\n    };\n  });\n  return wrappers;\n}\n\nexport default {\n  watch: makeWatchers()\n};","map":{"version":3,"sources":["/Users/muhammad/Ayaz/express-vue3-tailwind-map/client/node_modules/vue-mapbox/src/components/map/mixins/withWatchers.js"],"names":["watchers","maxBounds","next","map","setMaxBounds","minZoom","setMinZoom","maxZoom","setMaxZoom","mapStyle","setStyle","collisionBoxes","showCollisionBoxes","tileBoundaries","showTileBoundaries","repaint","zoom","setZoom","center","setCenter","bearing","setBearing","pitch","setPitch","light","setLigh","watcher","prop","callback","prev","initial","$listeners","propsIsUpdating","_watcher","active","$nextTick","makeWatchers","wrappers","Object","entries","forEach","call","bind","watch"],"mappings":"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","sourcesContent":["const watchers = {\n  maxBounds(next) {\n    this.map.setMaxBounds(next);\n  },\n  minZoom(next) {\n    this.map.setMinZoom(next);\n  },\n  maxZoom(next) {\n    this.map.setMaxZoom(next);\n  },\n  mapStyle(next) {\n    this.map.setStyle(next);\n  },\n  // TODO: make 'bounds' synced prop\n  // bounds (next) { this.map.fitBounds(next, { linear: true, duration: 0 }) },\n  collisionBoxes(next) {\n    this.map.showCollisionBoxes = next;\n  },\n  tileBoundaries(next) {\n    this.map.showTileBoundaries = next;\n  },\n  repaint(next) {\n    this.map.repaint = next;\n  },\n  zoom(next) {\n    this.map.setZoom(next);\n  },\n  center(next) {\n    this.map.setCenter(next);\n  },\n  bearing(next) {\n    this.map.setBearing(next);\n  },\n  pitch(next) {\n    this.map.setPitch(next);\n  },\n  light(next) {\n    this.map.setLigh(next);\n  }\n};\n\nfunction watcher(prop, callback, next, prev) {\n  if (this.initial) return;\n  if (this.$listeners[`update:${prop}`]) {\n    if (this.propsIsUpdating[prop]) {\n      this._watcher.active = false;\n      this.$nextTick(() => {\n        this._watcher.active = true;\n      });\n    } else {\n      this._watcher.active = true;\n      callback(next, prev);\n    }\n    this.propsIsUpdating[prop] = false;\n  } else {\n    callback(next, prev);\n  }\n}\n\nfunction makeWatchers() {\n  const wrappers = {};\n  Object.entries(watchers).forEach(prop => {\n    wrappers[prop[0]] = function(next, prev) {\n      return watcher.call(this, prop[0], prop[1].bind(this), next, prev);\n    };\n  });\n  return wrappers;\n}\n\nexport default {\n  watch: makeWatchers()\n};\n"]},"metadata":{},"sourceType":"module"}